"use strict";(self.webpackChunkude_a_io_t_page=self.webpackChunkude_a_io_t_page||[]).push([[2464],{6612:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=r(7624),t=r(4552);r(6212),r(2440),r(6968);const o={sidebar_label:"Ejemplo 3"},s="Ejemplo 3",a={id:"sesiones/percepcion/sesion9b_2_3",title:"Ejemplo 3",description:"Antes de empezar",source:"@site/docs/sesiones/percepcion/sesion9b_2_3.md",sourceDirName:"sesiones/percepcion",slug:"/sesiones/percepcion/sesion9b_2_3",permalink:"/UdeA_IoT-page/docs/sesiones/percepcion/sesion9b_2_3",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/sesiones/percepcion/sesion9b_2_3.md",tags:[],version:"current",frontMatter:{sidebar_label:"Ejemplo 3"},sidebar:"sesionesSidebar",previous:{title:"Ejemplo 2",permalink:"/UdeA_IoT-page/docs/sesiones/percepcion/sesion9b_2_2"},next:{title:"Interrupciones por timer",permalink:"/UdeA_IoT-page/docs/sesiones/percepcion/sesion9b_3"}},l={},c=[{value:"Antes de empezar",id:"antes-de-empezar",level:2},{value:"Enunciado",id:"enunciado",level:2},{value:"Hardware",id:"hardware",level:2},{value:"Componentes",id:"componentes",level:3},{value:"Esquem\xe1tico",id:"esquem\xe1tico",level:3},{value:"Conexion",id:"conexion",level:3},{value:"Sofware",id:"sofware",level:2},{value:"Caso 1 - Implementaci\xf3n por polling",id:"caso-1---implementaci\xf3n-por-polling",level:2},{value:"C\xf3digo",id:"c\xf3digo",level:3},{value:"Test",id:"test",level:3},{value:"Caso 2 - Implementaci\xf3n por interrupciones",id:"caso-2---implementaci\xf3n-por-interrupciones",level:2},{value:"C\xf3digo",id:"c\xf3digo-1",level:3},{value:"Test",id:"test-1",level:3},{value:"Caso 3 - Programa mejorado usando interrupciones",id:"caso-3---programa-mejorado-usando-interrupciones",level:2},{value:"C\xf3digo",id:"c\xf3digo-2",level:3},{value:"Test",id:"test-2",level:3},{value:"Referencias",id:"referencias",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"ejemplo-3",children:"Ejemplo 3"}),"\n",(0,i.jsx)(n.h2,{id:"antes-de-empezar",children:"Antes de empezar"}),"\n",(0,i.jsx)(n.p,{children:"ToDo... Hablar un poco sobre estas..."}),"\n",(0,i.jsx)(n.p,{children:"Las siguientes figuras muestran casos de uso de encoders rotativos:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Acceso al menu de control de dispositivos como impresoras 3d:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"er_uso1",src:r(5976).c+"",width:"450",height:"450"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Perilla de control de radios de los carros"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"er_uso2",src:r(5660).c+"",width:"1014",height:"396"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"enunciado",children:"Enunciado"}),"\n",(0,i.jsx)(n.p,{children:"El siguiente programa lo que hace es..."}),"\n",(0,i.jsx)(n.h2,{id:"hardware",children:"Hardware"}),"\n",(0,i.jsx)(n.h3,{id:"componentes",children:"Componentes"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"#"}),(0,i.jsx)(n.th,{children:"Elemento"}),(0,i.jsx)(n.th,{children:"Cantidad"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Placa de desarrollo ESP32"}),(0,i.jsx)(n.td,{children:"1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"Rotary encoder (37 sensor Kid de Elegoo)"}),(0,i.jsx)(n.td,{children:"1"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"esquem\xe1tico",children:"Esquem\xe1tico"}),"\n",(0,i.jsx)(n.p,{children:"A continuaci\xf3n se muestra esquematico del circuito:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"sch_e3",src:r(5428).c+"",width:"732",height:"810"})}),"\n",(0,i.jsx)(n.h3,{id:"conexion",children:"Conexion"}),"\n",(0,i.jsx)(n.p,{children:"A continuaci\xf3n se muestra el diagrama de conexi\xf3n:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"bb_e3",src:r(976).c+"",width:"744",height:"597"})}),"\n",(0,i.jsx)(n.h2,{id:"sofware",children:"Sofware"}),"\n",(0,i.jsx)(n.p,{children:"La diferentes implementaciones realizadas se muestran a continuaci\xf3n:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Caso 1 - Implementaci\xf3n por polling"}),"\n",(0,i.jsx)(n.li,{children:"Caso 2 - Implementaci\xf3n por interrupciones"}),"\n",(0,i.jsx)(n.li,{children:"Caso 3 - Programa mejorado usando interrupciones"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"caso-1---implementaci\xf3n-por-polling",children:"Caso 1 - Implementaci\xf3n por polling"}),"\n",(0,i.jsxs)(n.p,{children:["En esta implementaci\xf3n se puede estudiar analizando la ",(0,i.jsx)(n.strong,{children:"simulaci\xf3n online"})," (",(0,i.jsx)(n.a,{href:"https://wokwi.com/projects/367656993429289985",children:"link"}),")"]}),"\n",(0,i.jsx)(n.h3,{id:"c\xf3digo",children:"C\xf3digo"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <Arduino.h>\r\n\r\n/* ---- Pines I/O ---- */\r\n\r\n// Rotary encoder Encoder (I)\r\n#define ENCODER_CLK 14\r\n#define ENCODER_DT  12\r\n#define ENCODER_SW  13\r\n#define DEBUG 1\r\n\r\n// Constantes\r\nconst char MAX_PUSH_TIME = 50;\r\n\r\n// Variables aplicacion\r\nunsigned char counter = 0;       // Brillo led integrado\r\nint lastClk = HIGH;              // Valor anterior se\xf1al CLK\r\nlong int resetLastChanged = 0;   // cambio reset\r\n\r\n/* ---- Inicializaci\xf3n ---- */\r\nvoid setup() {\r\n  // Inicializacion serial\r\n  Serial.begin(115200);\r\n\r\n  // Inicializacion I/O\r\n  pinMode(LED_BUILTIN,OUTPUT);   \r\n  pinMode(ENCODER_CLK, INPUT);\r\n  pinMode(ENCODER_DT, INPUT);\r\n  pinMode(ENCODER_SW, INPUT_PULLUP);\r\n\r\n  // Impresion en el monitor serial\r\n  #if DEBUG\r\n    Serial.print("Counter: ");\r\n    Serial.println(counter);      \r\n  #endif\r\n\r\n}\r\n\r\n/* ---- Loop infinito ---- */\r\nvoid loop() {\r\n  // Chequeo del reset presionado por un tiempo mayor de MAX_PUSH_TIME \r\n  if (digitalRead(ENCODER_SW) == LOW && millis() - resetLastChanged > MAX_PUSH_TIME) {\r\n    resetLastChanged = millis();\r\n    counter = 0;\r\n    #if DEBUG\r\n      Serial.print("Counter: ");\r\n      Serial.println(counter);   \r\n    #endif\r\n    analogWrite(LED_BUILTIN,counter);   \r\n  }\r\n\r\n  // Actualizancion del brillo\r\n  int newClk = digitalRead(ENCODER_CLK);\r\n  if (newClk != lastClk) {\r\n    // There was a change on the CLK pin\r\n    lastClk = newClk;\r\n    int dtValue = digitalRead(ENCODER_DT);    \r\n    if (newClk == LOW && dtValue == HIGH) {\r\n      // Aumento brillo\r\n      counter++;\r\n      #if DEBUG\r\n        Serial.print("Counter: ");\r\n        Serial.println(counter);\r\n      #endif\r\n    }\r\n    if (newClk == LOW && dtValue == LOW) {\r\n      // Disminuci\xf3n brillo\r\n      counter--;\r\n      #if DEBUG\r\n        Serial.print("Counter: ");\r\n        Serial.println(counter);\r\n      #endif\r\n    }\r\n    analogWrite(LED_BUILTIN,counter);   \r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"test",children:"Test"}),"\n",(0,i.jsx)(n.p,{children:"La salida en el monitor serial de platformio se muestra a continuaci\xf3n:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"polling",src:r(2500).c+"",width:"1019",height:"549"})}),"\n",(0,i.jsx)(n.h2,{id:"caso-2---implementaci\xf3n-por-interrupciones",children:"Caso 2 - Implementaci\xf3n por interrupciones"}),"\n",(0,i.jsxs)(n.p,{children:["En esta implementaci\xf3n por interrupciones se puede analizar ejecutando la siguiente ",(0,i.jsx)(n.strong,{children:"simulaci\xf3n online"})," (",(0,i.jsx)(n.a,{href:"https://wokwi.com/projects/376267427485299713",children:"link"}),")"]}),"\n",(0,i.jsx)(n.h3,{id:"c\xf3digo-1",children:"C\xf3digo"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <Arduino.h>\r\n\r\n/* ---- Pines I/O ---- */\r\n\r\n// Rotary encoder Encoder (I)\r\n#define ENCODER_CLK 14\r\n#define ENCODER_DT  12\r\n#define ENCODER_SW  13\r\n#define DEBUG 1\r\n\r\n// Constantes\r\nconst char DEBOUNCE_TIME = 50;\r\n\r\n// Variables aplicacion\r\nvolatile unsigned char counter = 0;       // Brillo led integrado\r\nint valClk = HIGH;\r\nint dtValue = HIGH;\r\nlong int clkLastChanged = 0;     // cambio clk\r\nlong int resetLastChanged = 0;   // cambio reset\r\n\r\n// Reset del brillo\r\nvoid resetEncoder() {\r\n  if (digitalRead(ENCODER_SW) == LOW && millis() - resetLastChanged > DEBOUNCE_TIME) {\r\n    resetLastChanged = millis();\r\n    counter = 0;\r\n  }\r\n}\r\n\r\n// Actualizancion del brillo\r\nvoid updateEncoder() {\r\n  if ((millis() - clkLastChanged) < DEBOUNCE_TIME)  // debounce time is 50ms\r\n    return;\r\n  dtValue = digitalRead(ENCODER_DT);\r\n  if (dtValue == LOW) {\r\n    // Serial.println("DOWN"); \r\n    counter--;\r\n  }\r\n  else {\r\n    // Serial.println("UP"); \r\n    counter++;\r\n  }\r\n  clkLastChanged = millis();\r\n}\r\n\r\n/* ---- Inicializaci\xf3n ---- */\r\nvoid setup() {\r\n  // Inicializacion serial\r\n  Serial.begin(115200);\r\n\r\n  // Inicializacion I/O\r\n  pinMode(LED_BUILTIN,OUTPUT);   \r\n  pinMode(ENCODER_CLK, INPUT);\r\n  pinMode(ENCODER_DT, INPUT);\r\n  pinMode(ENCODER_SW, INPUT_PULLUP);\r\n\r\n  attachInterrupt(digitalPinToInterrupt(ENCODER_CLK), updateEncoder, CHANGE);\r\n  attachInterrupt(digitalPinToInterrupt(ENCODER_SW), resetEncoder, CHANGE);\r\n\r\n  // Impresion en el monitor serial\r\n  Serial.print("Counter: ");\r\n  Serial.println(counter);      \r\n}\r\n\r\n/* ---- Loop infinito ---- */\r\nvoid loop() {\r\n  // Chequeo del reset presionado por un tiempo mayor de MAX_PUSH_TIME \r\n  analogWrite(LED_BUILTIN,counter); \r\n  Serial.print("Counter: ");\r\n  Serial.println(counter);   \r\n  delay(100); \r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"test-1",children:"Test"}),"\n",(0,i.jsx)(n.p,{children:"La salida en el monitor serial se muestra a continuaci\xf3n:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"irq_1",src:r(8256).c+"",width:"1020",height:"530"})}),"\n",(0,i.jsx)(n.h2,{id:"caso-3---programa-mejorado-usando-interrupciones",children:"Caso 3 - Programa mejorado usando interrupciones"}),"\n",(0,i.jsxs)(n.p,{children:["La implementaci\xf3n de este c\xf3digo se muestra a continuaci\xf3n (",(0,i.jsx)(n.strong,{children:"Simulaci\xf3n"})," (",(0,i.jsx)(n.a,{href:"https://wokwi.com/projects/376427146413918209",children:"link"}),"))"]}),"\n",(0,i.jsx)(n.h3,{id:"c\xf3digo-2",children:"C\xf3digo"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <Arduino.h>\r\n\r\n/* ---- Pines I/O ---- */\r\n\r\n// Rotary encoder Encoder (I)\r\n#define ENCODER_CLK 14\r\n#define ENCODER_DT  12\r\n#define ENCODER_SW  13\r\n#define DEBUG 1\r\n\r\n// Constantes\r\nconst char DEBOUNCE_TIME = 50;\r\n\r\n// Variables aplicacion\r\nunsigned char counter = 0;       // Brillo led integrado\r\nint valClk = HIGH;\r\nint dtValue = HIGH;\r\nlong int clkLastChanged = 0;     // cambio clk\r\nlong int resetLastChanged = 0;   // cambio reset\r\n\r\n// Reset del brillo\r\nvolatile byte SW_EVENT = LOW;\r\nvolatile byte CKL_EVENT = LOW;\r\nvolatile byte PRINT_EVENT = LOW;\r\n\r\nhw_timer_t *timer_100m = NULL;       // H/W timer \r\n\r\n/* ---- Interrupt handlers ---- */\r\n\r\nvoid ARDUINO_ISR_ATTR event_print(){\r\n  PRINT_EVENT = HIGH;\r\n}\r\n\r\nvoid event_sw() {\r\n  SW_EVENT = HIGH;\r\n}\r\n\r\nvoid event_clk() {\r\n  CKL_EVENT = HIGH;\r\n}\r\n\r\n/* ---- Funciones ---- */\r\n\r\n// Reset encoder\r\nvoid resetEncoder() {\r\n  if (digitalRead(ENCODER_SW) == LOW && millis() - resetLastChanged > DEBOUNCE_TIME) {\r\n    resetLastChanged = millis();\r\n    counter = 0;\r\n  }\r\n}\r\n\r\n// Actualizancion del brillo\r\nvoid updateEncoder() {\r\n  if ((millis() - clkLastChanged) < DEBOUNCE_TIME)  // debounce time is 50ms\r\n    return;\r\n  dtValue = digitalRead(ENCODER_DT);\r\n  if (dtValue == LOW) {\r\n    // Serial.println("DOWN"); \r\n    counter--;\r\n  }\r\n  else {\r\n    // Serial.println("UP"); \r\n    counter++;\r\n  }\r\n  clkLastChanged = millis();\r\n}\r\n\r\n/* ---- Inicializaci\xf3n ---- */\r\nvoid setup() {\r\n  // Inicializacion serial\r\n  Serial.begin(115200);\r\n\r\n  // Inicializacion I/O\r\n  pinMode(LED_BUILTIN,OUTPUT);   \r\n  pinMode(ENCODER_CLK, INPUT);\r\n  pinMode(ENCODER_DT, INPUT);\r\n  pinMode(ENCODER_SW, INPUT_PULLUP);\r\n  \r\n  // Inicializacion de interrupciones externas\r\n  attachInterrupt(digitalPinToInterrupt(ENCODER_CLK), event_clk, CHANGE);\r\n  attachInterrupt(digitalPinToInterrupt(ENCODER_SW), event_sw, CHANGE);\r\n\r\n  // Inicializacion del timer \r\n  timer_100m = timerBegin(0, 80, true);\r\n  timerAttachInterrupt(timer_100m, &event_print, true);\r\n  timerAlarmWrite(timer_100m, 100000, true);\r\n  timerAlarmEnable(timer_100m);\r\n\r\n  // Impresion en el monitor serial\r\n  Serial.print("Counter: ");\r\n  Serial.println(counter);      \r\n}\r\n\r\n/* ---- Loop infinito ---- */\r\nvoid loop() {\r\n  // Evento reset\r\n  if (SW_EVENT == HIGH) {\r\n    // Serial.println("Debug: Reset event");\r\n    resetEncoder();    \r\n    analogWrite(LED_BUILTIN,counter); \r\n    SW_EVENT = LOW; // No olvidar (atencion del evento)\r\n  } \r\n  // Evento de actualizaci\xf3n del contador\r\n  if (CKL_EVENT == HIGH) {\r\n    // Serial.println("Debug: Update event");\r\n    updateEncoder();\r\n    analogWrite(LED_BUILTIN,counter); \r\n    CKL_EVENT = LOW; // No olvidar (atencion del evento)\r\n  } \r\n  // Evento para la impresion en pantalla\r\n  if (PRINT_EVENT == HIGH) {\r\n    Serial.print("Counter: ");\r\n    Serial.println(counter);   \r\n    PRINT_EVENT = LOW; // No olvidar (atencion del evento)\r\n  } \r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"test-2",children:"Test"}),"\n",(0,i.jsx)(n.p,{children:"Queda pendiente capturar la salida..."}),"\n",(0,i.jsx)(n.h2,{id:"referencias",children:"Referencias"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.upesy.com/blogs/tutorials/rotary-encoder-esp32-with-arduino-code",children:"https://www.upesy.com/blogs/tutorials/rotary-encoder-esp32-with-arduino-code"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://circuitdigest.com/microcontroller-projects/esp32-timers-and-timer-interrupts",children:"https://circuitdigest.com/microcontroller-projects/esp32-timers-and-timer-interrupts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.electronicwings.com/esp32/esp32-timer-interrupts",children:"https://www.electronicwings.com/esp32/esp32-timer-interrupts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://deepbluembedded.com/esp32-timers-timer-interrupt-tutorial-arduino-ide/",children:"https://deepbluembedded.com/esp32-timers-timer-interrupt-tutorial-arduino-ide/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://esp32io.com/tutorials/esp32-rotary-encoder",children:"https://esp32io.com/tutorials/esp32-rotary-encoder"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/igorantolic/ai-esp32-rotary-encoder",children:"https://github.com/igorantolic/ai-esp32-rotary-encoder"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.upesy.com/blogs/tutorials/rotary-encoder-esp32-with-arduino-code",children:"https://www.upesy.com/blogs/tutorials/rotary-encoder-esp32-with-arduino-code"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.arduino.cc/reference/en/libraries/ai-esp32-rotary-encoder/",children:"https://www.arduino.cc/reference/en/libraries/ai-esp32-rotary-encoder/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://electricdiylab.com/how-to-connect-optical-encoder-with-esp32/",children:"https://electricdiylab.com/how-to-connect-optical-encoder-with-esp32/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://esp32tutorials.com/esp32-pulse-counter-pcnt-esp-idf-rotary-encoder/",children:"https://esp32tutorials.com/esp32-pulse-counter-pcnt-esp-idf-rotary-encoder/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.adafruit.com/product/5734",children:"https://www.adafruit.com/product/5734"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5976:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/display_re-82573eee7b1232e2f2754136343088a7.png"},5660:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/radio_re-7f92cf1df99ac50f2839d23648c43dea.png"},976:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/rotary_encorder-ESP32_bb-f632edd23ed9906105613c930e67d181.png"},5428:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/rotary_encorder-ESP32_sch-8464bf3bf81dc6e91d661e8ad4770053.png"},8256:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/rotary_irq-ESP32-76611a9ae2a833df26862ae57225d8b8.png"},2500:(e,n,r)=>{r.d(n,{c:()=>i});const i=r.p+"assets/images/rotary_polling-ESP32-c0f7e5d6a747e9a1b39c50b8574906a2.png"}}]);